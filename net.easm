;; setup OP1 jump table in memory[0:0x200]
PUSH @num_opI_add
PUSH 0x000
MSTORE
PUSH @num_opI_sub
PUSH 0x020
MSTORE
PUSH @num_opI_mul
PUSH 0x040
MSTORE
PUSH @num_opI_div
PUSH 0x060
MSTORE
PUSH @num_opI_mod
PUSH 0x080
MSTORE
PUSH @num_opI_pow
PUSH 0x0a0
MSTORE
PUSH @num_opI_and
PUSH 0x0c0
MSTORE
PUSH @num_opI_bor
PUSH 0x0e0
MSTORE
PUSH @num_opI_xor
PUSH 0x100
MSTORE
PUSH @num_opI_not
PUSH 0x120
MSTORE
PUSH @num_opI_shr
PUSH 0x140
MSTORE
PUSH @num_opI_shl
PUSH 0x160
MSTORE
PUSH @num_opI_gtr
PUSH 0x180
MSTORE
PUSH @num_opI_les
PUSH 0x1a0
MSTORE
PUSH @num_opI_eql
PUSH 0x1c0
MSTORE
;; XXX: floating point operations?

;; load net into memory[0x200]
CALLDATASIZE
DUP1
PUSH 0
PUSH 0x200
CALLDATACOPY

;; push address onto stack
PUSH 2112
PUSH 2
SHL

rewrite:
	;; load node A
	DUP1
	PUSH 2
	SHL
	PUSH 0x200
	ADD
	DUP1
	MLOAD

	;; push A[0:3] onto stack
	PUSH 128
	SHR
	DUP1
	PUSH 0xffffffff
	AND
	SWAP1
	PUSH 32
	SHR
	DUP1
	PUSH 0xffffffff
	AND
	SWAP1
	PUSH 32
	SHR
	DUP1
	PUSH 0xffffffff
	AND
	SWAP1
	PUSH 32
	SHR

	;; push A type
	DUP4
	PUSH 3
	AND

	;; A type == PTR -> @ptr
	DUP1
	ISZERO
	JUMPI @ptr

	;; A type == NUM -> @num
	PUSH 1
	EQ
	JUMPI @num

	;; otherwise -> @era
era:
	;; TODO: implement
	STOP

num:
	;; load A kind
	DUP4
	PUSH 6
	SHR
	PUSH 3
	AND

	;; A kind == CON -> @num_con
	DUP1
	ISZERO
	JUMPI @num_con

	;; A kind == OP1 -> @num_op1
	DUP1
	PUSH 1
	EQ
	JUMPI @num_opI

	;; A kind == OP2 -> @num_opII
	PUSH 2
	EQ
	JUMPI @num_opII

	;; otherwise -> @num_ite
	;; TODO: implement
	STOP

num_opI:
	POP

	;; load op code
	DUP4
	PUSH 8
	SHR

	;; jump to op label
	PUSH 5
	SHL
	MLOAD
	JUMP

num_opI_add:
	ADD
	JUMP @num_opI_finish
num_opI_sub:
	SUB
	JUMP @num_opI_finish
num_opI_mul:
	MUL
	JUMP @num_opI_finish
num_opI_div:
	DIV
	JUMP @num_opI_finish
num_opI_mod:
	MOD
	JUMP @num_opI_finish
num_opI_pow:
	EXP
	JUMP @num_opI_finish
num_opI_and:
	AND
	JUMP @num_opI_finish
num_opI_bor:
	OR
	JUMP @num_opI_finish
num_opI_xor:
	XOR
	JUMP @num_opI_finish
num_opI_not:
	NOT
	JUMP @num_opI_finish
num_opI_shr:
	SHR
	JUMP @num_opI_finish
num_opI_shl:
	SHL
	JUMP @num_opI_finish
num_opI_gtr:
	GT
	JUMP @num_opI_finish
num_opI_les:
	LT
	JUMP @num_opI_finish
num_opI_eql:
	EQ

num_opI_finish:
	PUSH 224
	SHL

	;; XXX: condition on A type[2] == PTR

	;; load net[A[2]]
	SWAP1
	PUSH 2
	SHL
	PUSH 0x200
	ADD
	DUP1
	SWAP2
	DUP2
	MLOAD

	;; set port to result
	PUSH 0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff
	AND
	OR
	SWAP1
	MSTORE

	;; set port type to NUM
	PUSH 0xf
	OR
	DUP1
	MLOAD
	PUSH 1
	OR
	SWAP1
	MSTORE8

	POP
	;; XXX: free A addr
	POP
	JUMP @return

num_opII:
	;; swap A[0] and A[1]
	SWAP1

	SWAP3

	;; push OP1 << 6 | NUM << 2
	PUSH 0x44

	;; push A[3] & ~(3 << 6 | 3 << 0 | 3 << 2)
	DUP2
	PUSH 0xffffff30
	AND

	;; push A[3] >> 2 & 3
	SWAP2
	PUSH 2
	SHR
	PUSH 3
	AND

	DUP1
	PUSH 0
	LT
	JUMPI @num_opII_nonptr

	;; load net[A[0]]
	DUP6
	PUSH 2
	SHL
	PUSH 0x200
	ADD
	DUP1
	MLOAD

	;; set port to 0 then store
	PUSH 0xfffffffcffffffffffffffffffffffffffffffffffffffffffffffffffffffff
	AND
	SWAP1
	MSTORE

num_opII_nonptr:
	OR
	OR
	SWAP3

	JUMP @store_A

num_con:
	POP
	;; TODO: implement
	STOP

ptr:
	POP
	;; TODO: implement
	STOP

store_A:
	;; load A[0:3] into stack[0] bits 128:255
	PUSH 96
	SHL
	SWAP1
	PUSH 64
	SHL
	OR
	SWAP1
	PUSH 32
	SHL
	OR
	OR
	PUSH 128
	SHL

	;; store stack[0] into net[A addr]
	DUP2
	MLOAD
	PUSH 0xffffffffffffffffffffffffffffffff
	AND
	OR
	SWAP1
	MSTORE

return:
	POP

	;; return net
	PUSH 0x200
	RETURN
